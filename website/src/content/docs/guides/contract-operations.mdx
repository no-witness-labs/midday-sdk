---
title: Contract Operations
description: Deploy, join, and interact with smart contracts
---

import { Steps, Tabs, TabItem } from '@astrojs/starlight/components';

## Loading a Contract

Each contract has its own zk circuits - this is a first principle. The SDK loads zkConfig automatically when you specify a path:

```typescript
// Node.js - load from path (zkConfig loaded automatically)
const contract = await client.loadContract({ 
  path: join(__dirname, './contracts/my-contract') 
});

// Browser - load from URLs (zkConfig base URL specified)
const contract = await client.loadContract({
  moduleUrl: 'https://cdn.example.com/contracts/my-contract/index.js',
  zkConfigBaseUrl: 'https://cdn.example.com/contracts/my-contract',
});
```

## Creating a Client

Create a client (zkConfig is per-contract, not per-client):

```typescript
const client = await Midday.Client.create({
  networkConfig: Midday.Config.NETWORKS.local,
  privateStateProvider: Midday.PrivateState.inMemoryPrivateStateProvider(),
});
```

## Contract Loading Options

### Option 1: Load from Path (Node.js)

The simplest approach for Node.js - zkConfig loaded from the same directory:

```typescript
const contract = await client.loadContract({ 
  path: join(__dirname, './contracts/my-contract') 
});
console.log(contract.state); // 'loaded'
```

### Option 2: Load from URLs (Browser)

For browser environments, specify the module URL and zkConfig base URL:

```typescript
const contract = await client.loadContract({
  moduleUrl: 'https://cdn.example.com/contracts/my-contract/index.js',
  zkConfigBaseUrl: 'https://cdn.example.com/contracts/my-contract',
});
```

### Option 3: Pre-loaded Module with zkConfig

If you've already loaded the module and zkConfig separately:

```typescript
const contract = await client.loadContract({ module, zkConfig });
```

### With Witnesses

Witnesses are client-side functions that provide private data to contract computations:

```typescript
const contract = await client.loadContract({
  path: './contracts/my-contract',
  witnesses: {
    my_witness_function: (context) => {
      // Return private data for the contract
      return somePrivateValue;
    },
  },
});
```

### With Custom Private State ID

```typescript
const contract = await client.loadContract({
  path: './contracts/my-contract',
  privateStateId: 'my-unique-state-id',
});
```

## Contract State Machine

Contracts have two states:
- **loaded**: Contract module loaded, ready for `deploy()` or `join()`
- **deployed**: Connected to the network, ready for `call()` and `ledgerState()`

```typescript
const contract = await client.loadContract({ path: './contracts/my-contract' });
console.log(contract.state);   // 'loaded'
console.log(contract.address); // undefined

await contract.deploy();
console.log(contract.state);   // 'deployed'
console.log(contract.address); // '0x1234...abcd'
```

## Deploying a Contract

Deploy a new instance of a contract to the network:

```typescript
await contract.deploy();
console.log(`Deployed at: ${contract.address}`);
```

The deploy operation:
1. Compiles the contract if needed
2. Generates the deployment transaction
3. Submits it to the network
4. Waits for confirmation
5. Transitions the contract to "deployed" state

## Joining an Existing Contract

Connect to a contract that's already deployed:

```typescript
await contract.join('0x1234...abcd');
console.log(contract.address); // '0x1234...abcd'
```

## Calling Contract Actions

Execute a state-changing action on the contract:

```typescript
const result = await contract.call('increment');

console.log(`TX Hash: ${result.txHash}`);
console.log(`Block: ${result.blockHeight}`);
```

### With Arguments

Pass arguments to contract actions:

```typescript
const result = await contract.call('transfer', recipientAddress, 100n);
```

## Reading Contract State

### Current State

Get the parsed ledger state:

```typescript
const state = await contract.ledgerState();
console.log(state.counter); // Access state fields
```

### Raw State

Get the unparsed state:

```typescript
const rawState = await contract.state();
```

### Historical State

Query state at a specific block height:

```typescript
const historicalState = await contract.ledgerStateAt(blockHeight);
```

## Complete Example

<Tabs>
  <TabItem label="Promise API">
    ```typescript
    import * as Midday from '@no-witness-labs/midday-sdk';
    import { join } from 'path';

    // Create client (no zkConfig needed at client level)
    const client = await Midday.Client.create({
      networkConfig: Midday.Config.NETWORKS.local,
      privateStateProvider: Midday.PrivateState.inMemoryPrivateStateProvider(),
    });

    // Load contract from path (zkConfig loaded automatically)
    const contract = await client.loadContract({ 
      path: join(__dirname, './contracts/counter') 
    });
    
    // Deploy and interact
    await contract.deploy();
    await contract.call('increment');
    const state = await contract.ledgerState();
    console.log(`Counter: ${state.counter}`);
    ```
  </TabItem>
  <TabItem label="Effect API">
    ```typescript
    import * as Midday from '@no-witness-labs/midday-sdk';
    import { Effect } from 'effect';
    import { join } from 'path';

    const program = Effect.gen(function* () {
      // Create client
      const client = yield* Midday.Client.effect.create({
        networkConfig: Midday.Config.NETWORKS.local,
        privateStateProvider: Midday.PrivateState.inMemoryPrivateStateProvider(),
      });

      // Load contract from path (zkConfig loaded automatically)
      const contract = yield* client.effect.loadContract({ 
        path: join(__dirname, './contracts/counter') 
      });
      
      // Deploy and interact
      yield* contract.effect.deploy();
      yield* contract.effect.call('increment');
      const state = yield* contract.effect.ledgerState();

      return state;
    });

    const result = await Midday.Runtime.runEffectPromise(program);
    console.log(`Counter: ${result.counter}`);
    ```
  </TabItem>
</Tabs>

## Error Handling

Contract operations can fail for various reasons:

| Error | Cause |
|-------|-------|
| `ContractError` | General contract operation failure |
| `ClientError` | Client initialization or configuration error |

With the Effect API, errors are typed and can be handled explicitly:

```typescript
const program = contract.effect.call('increment').pipe(
  Effect.catchTag('ContractError', (error) => {
    console.error('Contract operation failed:', error.message);
    return Effect.fail(error);
  })
);
```

## Waiting for Transactions

If you need to wait for a specific transaction to be finalized:

```typescript
const result = await contract.call('increment');
const finalized = await client.waitForTx(result.txHash);
console.log(`Finalized at block: ${finalized.blockHeight}`);
```
